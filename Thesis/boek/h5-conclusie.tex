\chapter{Conclusie}

Het ontwikkelde systeem zal in dit hoofdstuk worden getoetst aan de doelen en criteria beschreven in hoofdstuk \ref{introductie}. Ook zullen enkele mogelijke toekomstige verbeteringen besproken worden.

\section{Doelen}

Het eerste doel was dat de algoritmes aangepast en/of geoptimaliseerd moeten worden zodat ze de latency tussen audiofragmenten opgenomen met een basic microfoon kunnen bepalen tot op minstens één milliseconde nauwkeurig. De praktijktest beschreven in \ref{praktijktest} toont aan dat dit mogelijk is.

Het tweede doel is de implementatie van de softwarebibliotheek. Met behulp van deze bibliotheek moet het mogelijk zijn om programmatisch streams te kunnen aanmaken en synchroniseren. Het ontwerp van deze softwarebibliotheek is omschreven in \ref{ontwerp}. Dit toont aan dat het doel ook is verwezenlijkt.

Het derde doel is ook succesvol voltooid. De gebruikersinterface kan door musicologen zelf worden samengesteld in Max/MSP. In de praktijktest is aangetoond dat het mogelijk is om streams in te lezen en de latency tussen de streams te bepalen. Met behulp van deze latency kan de module de streams synchroniseren.

\section{Beoordeling algoritmes}

In \ref{evaluatie-criteria} werden enkele meer specifieke criteria opgelegd waaraan de algoritmes moet voldoen.

Het eerste criterium stelt dat het mogelijk moet zijn om met een buffergrootte (de grootte van de slices) van maximaal 10 seconden de synchronisatie uit te voeren. De testen omschreven in \ref{algoritme-test} en \ref{praktijktest} zijn uitgevoerd met de vooropgestelde buffergrootte en zijn geslaagd. Het huidige systeem voldoet dus aan dit criterium.

Het tweede criterium bepaalt de snelheid waarmee gedropte samples gedetecteerd kunnen worden. In de fase van het onderzoek waarin deze criteria zijn opgesteld was het nog onduidelijk welke factoren hier allemaal invloed op hebben. In sectie \ref{streambuffers} is onder meer omschreven welke invloed de grootte en stapgrootte van de buffers hebben op de detectiesnelheid. Ook het eventueel filteren van de resultaten (beschreven in \ref{filtering}) heeft een invloed op de detectiesnelheid. De testen die in hoofdstuk \ref{evaluatie} omschreven werden voldoen aan de vooropgestelde maximale detectiesnelheid van 10 seconden. Er werd namelijk een slicegrootte van 10 seconden en stapgrootte van 5 seconde gehanteerd. Deze maximale detectiesnelheid kan met deze instellingen niet worden bereikt indien er aan foutcorrectie wordt gedaan.

Volgens het laatste criterium moet het mogelijk moet zijn om drift te detecteren. De detectiesnelheid hiervan is gelijk aan de snelheid waarmee gedropte samples gedetecteerd kunnen worden. In de praktijktest trad dit verschijnsel op. Het is dus bewezen dat dit mogelijk is.

Het is duidelijk dat van de besproken algoritmen uit de introductie (sectie \ref{bestaande-methoden}) acoustic fingerprinting kruiscovariantie het meest geschikt waren voor het onderzochte probleem. Dat het systeem zo goed presteert is grotendeels te danken aan de robuuste fundamenten waarop alles gebouwd is.

\section{Mogelijke verbeteringen en uitbreiding}

Het experiment uit de probleemschets maakte gebruik van een accelerometer, een videocamera en afgespeelde muziek. Met het huidige systeem is het mogelijk om de datastream van de accelerometer te synchroniseren met de afgespeelde muziek. Deze signalen kunnen namelijk verwerkt worden in Max/MSP. 

Hoewel het geluid van de beelden als Max/MSP signaal verwerkt kan worden is dit niet het geval voor de bijhorende beelden. Een mogelijke uitbreiding van het huidige systeem omvat het ontwikkelen van een Jitter variant van de huidige synchronisatiemodule. Jitter is een uitbreiding van Max waarmee realtime video verwerkt kan worden. Ondanks dat er nog geen verder onderzoek gedaan is naar de haalbaarheid hiervan kan het ontwikkelen van een Jitter module eventueel een oplossing bieden voor het hierboven beschreven probleem.

Een ander soort data dat bij bepaalde experimenten gebruikt wordt is MIDI. In de huidige implementatie wordt dit nog niet ondersteund. Het ontwikkelen van een Max/MSP omzetmodule die MIDI gegevens van en naar Max/MSP signalen converteert zou dit probleem kunnen oplossen. Artikel \cite{mspmidi} legt uit hoe MIDI naar een Max/MSP signaal gemapt kan worden.

\section{Terugblik}

Bij het vergelijken van het bereikte resultaat met de originele opdracht heb ik het gevoel dat ik de masterproef met succes volbracht heb. Ik ben er namelijk in geslaagd om het synchroniseren van datastreams zonder nabewerking mogelijk te maken. Ook heb ik een flexibele interface ontworpen in Max/MSP.

Het uitwerken van de eerste uitbreiding (het sleutelen aan de algoritmes) was soms noodzakelijk om de kwaliteit van het nieuwe systeem te garanderen.